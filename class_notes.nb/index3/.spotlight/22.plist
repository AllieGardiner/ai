<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>keywords</key>
	<string></string>
	<key>txt</key>
	<string>Wednesday, January 21, 2009 Knowledge Representation object attribute-value list dog = { :color =&gt; 'brown', :size =&gt; 'tiny', :breed =&gt; chihuahua, :gender =&gt; 'male' } in LISP - every atom has a property list atom = { :value =&gt; 10, :type =&gt; int, :function =&gt; funcbinding } p-list used to create attribute-value binding for atoms (prop1 val1 prop2 val2 prop3 val3 ... ...) (get sym key) (setf (get sym key) newval) (remprop sym key) (symbol-plist sym)  &gt;  (PROP1 VAL1 PROP2 VAL2 ... ...) a-list ((prop1.val1) (prop2.val2) (prop3.val3)) (assoc key a-list)  &gt;  (PROP1.VAL1)  - usually use with cdr to get value (rassoc val a-list)  &gt;  (PROP1.VAL1)  - usually use with car to get property (setq a-list (cons (cons px vx) a-list))  =&gt;  (setq a-list (acons px vx a-list)) (setq a-list (pairlis plist vlist a-list)) (setq dog (pairlis '(color size breed) '(brown tiny yorkie))) (cdr (assoc 'color dog))  &gt;  BROWN Propositional Logic expressions - wff (well formed formula) propositions symbol that represents a statement Today is Sunny The Room is Cold A - I will ace the tests B - I will do all the homework C - I will get an "A" A ∧ B ⇒ C operators (connectives) ∧ and ∨ or ¬ not ⇒ implies Laws DeMorgan's ¬ (A ∧ B) ≡ ¬ A ∨ ¬ B ¬ (A ∨ B) ≡ ¬ A ∧ ¬ B ¬ (¬ A) ≡ A A ∧ (B ∨ C) ≡ (A ∧ B) ∨ (A ∧ C) Assoc A ∧ (B ∧ C) ≡ (A ∧ B) ∧ C Assertion A ∧ B ⇒ A B A, A ⇒ B ⇒ B    modus ponens ¬ B, A ⇒ B ⇒ ¬ A   modus tolens A, ¬ A ∨ B ⇒ B   resolution A ⇒ B ≡ ¬ A ∨ B Predicate Calculus functions predicates (true or false) connectives quantifiers operate on variables - domain of values (type) ∀ - universal ∃ - existential Laws ¬ ∀ x ⇒ ∃ x ¬ ¬ ∃ x ⇒ ∀ x ¬    it is not true that there is an x for which the following expression is true, therefore for every x, the following expression is false If it is sunny and not a workday, Bob will be out walking his dog. Propositional A ≡ it is sunny B ≡ it is a workday C ≡ Bob walks his dog A ∧ ¬ B ⇒ C Predicate weather(day, type) weekday(day) doing(person, day, activity) ∀ day weather(day, Sunny) ∧ ¬ weekday(day) ⇒ doing(Bob, day, Walk Dog) All men are mortal, Socrates is a man, ∴ Socrates is mortal human(being) ⇒ mortal(being) we can do better! ∀x human(x) ⇒ ∃day dead(x, day) we can still do better! ∀x human(x) ⇒ ∃day1 ∃day2 alive(x, day1) ∧ dead(x, day2) ∧ after(day2, day1) human(Socrates) ⇒ ∃day1 ∃day2 alive(Socrates, 220BC) ∧ dead(Socrates, 2009AD) ∧ after(220BC, 2009AD) Clause Form (Conjunct of Disjuncts) replace ⇒  A ⇒ B with ￢A ∨ B reduce scope of ¬ move ¬ to front of predicates unique quantifier variables quantifier moved left eliminate ∃ using Skolem's function or constant Drop ∀ quantifiers - any variables left are universally quantified Convert ∧ top-level, ∨ bottom-level (* ∨ * ∨ *) ∧ (* ∨ *) ∧ (* ∨ * ∨ * ∨ *) Split ∧ groups - each gets a line in the knowledge base Unique variables We're left with predicates or negated predicates or-ed together What can you do with a knowledge base in clause form? the only law we need is resolution A ∨ ¬ B ∨ C D ∨ B ∨ ¬ F any two clauses which contain an assertive predicate and negated predicate can be joined A ∨ C ∨ D ∨ ¬ F Systematically try every possible resolution Keep index of all assertive and negated predicates Avoid:  A, ¬A    CONTRADICTION! </string>
</dict>
</plist>
