<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>keywords</key>
	<string></string>
	<key>txt</key>
	<string>Monday, January 26, 2009 Knowledge Base in Clause Form - Knowledge Representation verify logical consistency prove new statements methods deduction - through logic induction - by experience adduction - come up with new statements you think are true that you then try to prove first negate statement then convert to clause form use resolution to try to come up with a contridiction because we first assumed our statement is false, finding a contradiction proves it is true if you can't find a contradiction, try to prove our statement false start over again, but without negating our statement if we find a contradiction, then our statement is false if you can't find it true or false, then statement is not derivable from the knowledge base, but it is still consistent with the knowledge base - still okay to add to the knowledge base answer questions about our knowledge base "Who was vice president in 1837?" vicepresident(X, 1837) leave a variable for the question you want answered negate your clause, and plug it into the knowledge base use unify function to come up with substitution list substitution list is our answer Unification - page 69 makes two clauses in a knowledge base match up takes two predicates as arguments UNIFY(E1, E2) E1 = weather(date, kind) E2 = weather(....., ......) predicates must be the same do arguments match? if arguments are same constants, then they match if one argument is variable and other is function call, substitute variable with function call UNLESS - function contains that variable, then you get infinite recursion p(X, bob, mother(X)) p(joe, Y, Z) can these be unified? both p predicate - good {joe/X, bob/Y, mother(joe)/Z} p(joe, bob, mother(joe)) p(joe, bob, mother(joe)) Problem Solving Physical Symbol System model of computer processing take the facts, represent them with different symbols take facts about real world, encode them into data (symbols), come up with conclusions "We believe that every intelligent behavior can be represented by symbols that can be processed by computers" Problem Solving Techniques Decomposing Problem into Sub-Problems Predictable Universe - try this, get this result - deterministic Absolute vs Relative - don't succeed unless you find best solution to problem Interactive - playing video games vs solving algebra problem State Space Search weak-search methods brute force search strong-search methods directed search heuristics Methods Defining &amp; Representing Space/States Start State Recognize Goal State(s) Move Generator (how to get from state to state) Strategy Don't duplicate states - get stuck in a loop Top-Down (Forward) better for many goal states, one start state Bottom-Up (Backward) better for one goal state, many start states Breadth First more memory most efficient solution Depth First less memory stack based not guaranteed to find best solution </string>
</dict>
</plist>
